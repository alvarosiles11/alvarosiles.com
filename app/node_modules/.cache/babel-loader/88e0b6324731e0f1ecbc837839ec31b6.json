{"ast":null,"code":"/**\r\n * Adapts focus styles based on the user's active input modality (i.e., how\r\n * they are interacting with the UI right now).\r\n *\r\n * Focus styles are only relevant when using the keyboard to interact with the\r\n * page. If we only show the focus ring when relevant, we can avoid user\r\n * confusion without compromising accessibility.\r\n *\r\n * The script uses two heuristics to determine whether the keyboard is being used:\r\n *\r\n * 1. a keydown event occurred immediately before a focus event;\r\n * 2. a focus event happened on an element which requires keyboard interaction (e.g., a text field);\r\n *\r\n * This software or document includes material copied from or derived from https://github.com/WICG/focus-visible.\r\n * Copyright © 2018 W3C® (MIT, ERCIM, Keio, Beihang).\r\n * W3C Software Notice and License: https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n *\r\n * \r\n */\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nvar focusVisibleAttributeName = 'data-focusvisible-polyfill';\nvar rule = \":focus:not([\" + focusVisibleAttributeName + \"]){outline: none;}\";\nvar modality = function modality(insertRule) {\n  insertRule(rule);\n  if (!canUseDOM) {\n    return;\n  }\n  var hadKeyboardEvent = true;\n  var hadFocusVisibleRecently = false;\n  var hadFocusVisibleRecentlyTimeout = null;\n  var inputTypesWhitelist = {\n    text: true,\n    search: true,\n    url: true,\n    tel: true,\n    email: true,\n    password: true,\n    number: true,\n    date: true,\n    month: true,\n    week: true,\n    time: true,\n    datetime: true,\n    'datetime-local': true\n  };\n  /**\r\n   * Helper function for legacy browsers and iframes which sometimes focus\r\n   * elements like document, body, and non-interactive SVG.\r\n   */\n\n  function isValidFocusTarget(el) {\n    if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Computes whether the given element should automatically trigger the\r\n   * `focus-visible` attribute being added, i.e. whether it should always match\r\n   * `:focus-visible` when focused.\r\n   */\n\n  function focusTriggersKeyboardModality(el) {\n    var type = el.type;\n    var tagName = el.tagName;\n    var isReadOnly = el.readOnly;\n    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !isReadOnly) {\n      return true;\n    }\n    if (tagName === 'TEXTAREA' && !isReadOnly) {\n      return true;\n    }\n    if (el.isContentEditable) {\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Add the `focus-visible` attribute to the given element if it was not added by\r\n   * the author.\r\n   */\n\n  function addFocusVisibleAttribute(el) {\n    if (el.hasAttribute(focusVisibleAttributeName)) {\n      return;\n    }\n    el.setAttribute(focusVisibleAttributeName, true);\n  }\n  /**\r\n   * Remove the `focus-visible` attribute from the given element if it was not\r\n   * originally added by the author.\r\n   */\n\n  function removeFocusVisibleAttribute(el) {\n    el.removeAttribute(focusVisibleAttributeName);\n  }\n  /**\r\n   * Remove the `focus-visible` attribute from all elements in the document.\r\n   */\n\n  function removeAllFocusVisibleAttributes() {\n    var list = document.querySelectorAll(\"[\" + focusVisibleAttributeName + \"]\");\n    for (var i = 0; i < list.length; i += 1) {\n      removeFocusVisibleAttribute(list[i]);\n    }\n  }\n  /**\r\n   * Treat `keydown` as a signal that the user is in keyboard modality.\r\n   * Apply `focus-visible` to any current active element and keep track\r\n   * of our keyboard modality state with `hadKeyboardEvent`.\r\n   */\n\n  function onKeyDown(e) {\n    if (e.key !== 'Tab' && (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)) {\n      return;\n    }\n    if (isValidFocusTarget(document.activeElement)) {\n      addFocusVisibleAttribute(document.activeElement);\n    }\n    hadKeyboardEvent = true;\n  }\n  /**\r\n   * If at any point a user clicks with a pointing device, ensure that we change\r\n   * the modality away from keyboard.\r\n   * This avoids the situation where a user presses a key on an already focused\r\n   * element, and then clicks on a different element, focusing it with a\r\n   * pointing device, while we still think we're in keyboard modality.\r\n   * It also avoids the situation where a user presses on an element within a\r\n   * previously keyboard-focused element (i.e., `e.target` is not the previously\r\n   * focused element, but one of its descendants) and we need to remove the\r\n   * focus ring because a `blur` event doesn't occur.\r\n   */\n\n  function onPointerDown(e) {\n    if (hadKeyboardEvent === true) {\n      removeAllFocusVisibleAttributes();\n    }\n    hadKeyboardEvent = false;\n  }\n  /**\r\n   * On `focus`, add the `focus-visible` attribute to the target if:\r\n   * - the target received focus as a result of keyboard navigation, or\r\n   * - the event target is an element that will likely require interaction\r\n   *   via the keyboard (e.g. a text box)\r\n   */\n\n  function onFocus(e) {\n    // Prevent IE from focusing the document or HTML element.\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n      addFocusVisibleAttribute(e.target);\n    }\n  }\n  /**\r\n   * On `blur`, remove the `focus-visible` attribute from the target.\r\n   */\n\n  function onBlur(e) {\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n    if (e.target.hasAttribute(focusVisibleAttributeName)) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n        hadFocusVisibleRecently = false;\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      }, 100);\n      removeFocusVisibleAttribute(e.target);\n    }\n  }\n  /**\r\n   * If the user changes tabs, keep track of whether or not the previously\r\n   * focused element had the focus-visible attribute.\r\n   */\n\n  function onVisibilityChange(e) {\n    if (document.visibilityState === 'hidden') {\n      // If the tab becomes active again, the browser will handle calling focus\n      // on the element (Safari actually calls it twice).\n      // If this tab change caused a blur on an element with focus-visible,\n      // re-apply the attribute when the user switches back to the tab.\n      if (hadFocusVisibleRecently) {\n        hadKeyboardEvent = true;\n      }\n      addInitialPointerMoveListeners();\n    }\n  }\n  /**\r\n   * Add a group of listeners to detect usage of any pointing devices.\r\n   * These listeners will be added when the polyfill first loads, and anytime\r\n   * the window is blurred, so that they are active when the window regains\r\n   * focus.\r\n   */\n\n  function addInitialPointerMoveListeners() {\n    document.addEventListener('mousemove', onInitialPointerMove);\n    document.addEventListener('mousedown', onInitialPointerMove);\n    document.addEventListener('mouseup', onInitialPointerMove);\n    document.addEventListener('pointermove', onInitialPointerMove);\n    document.addEventListener('pointerdown', onInitialPointerMove);\n    document.addEventListener('pointerup', onInitialPointerMove);\n    document.addEventListener('touchmove', onInitialPointerMove);\n    document.addEventListener('touchstart', onInitialPointerMove);\n    document.addEventListener('touchend', onInitialPointerMove);\n  }\n  function removeInitialPointerMoveListeners() {\n    document.removeEventListener('mousemove', onInitialPointerMove);\n    document.removeEventListener('mousedown', onInitialPointerMove);\n    document.removeEventListener('mouseup', onInitialPointerMove);\n    document.removeEventListener('pointermove', onInitialPointerMove);\n    document.removeEventListener('pointerdown', onInitialPointerMove);\n    document.removeEventListener('pointerup', onInitialPointerMove);\n    document.removeEventListener('touchmove', onInitialPointerMove);\n    document.removeEventListener('touchstart', onInitialPointerMove);\n    document.removeEventListener('touchend', onInitialPointerMove);\n  }\n  /**\r\n   * When the polfyill first loads, assume the user is in keyboard modality.\r\n   * If any event is received from a pointing device (e.g. mouse, pointer,\r\n   * touch), turn off keyboard modality.\r\n   * This accounts for situations where focus enters the page from the URL bar.\r\n   */\n\n  function onInitialPointerMove(e) {\n    // Work around a Safari quirk that fires a mousemove on <html> whenever the\n    // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\n    if (e.target.nodeName === 'HTML') {\n      return;\n    }\n    hadKeyboardEvent = false;\n    removeInitialPointerMoveListeners();\n  }\n  document.addEventListener('keydown', onKeyDown, true);\n  document.addEventListener('mousedown', onPointerDown, true);\n  document.addEventListener('pointerdown', onPointerDown, true);\n  document.addEventListener('touchstart', onPointerDown, true);\n  document.addEventListener('focus', onFocus, true);\n  document.addEventListener('blur', onBlur, true);\n  document.addEventListener('visibilitychange', onVisibilityChange, true);\n  addInitialPointerMoveListeners();\n};\nexport default modality;","map":{"version":3,"names":["canUseDOM","focusVisibleAttributeName","rule","modality","insertRule","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","isValidFocusTarget","el","document","nodeName","classList","focusTriggersKeyboardModality","type","tagName","isReadOnly","readOnly","isContentEditable","addFocusVisibleAttribute","hasAttribute","setAttribute","removeFocusVisibleAttribute","removeAttribute","removeAllFocusVisibleAttributes","list","querySelectorAll","i","length","onKeyDown","e","key","metaKey","altKey","ctrlKey","shiftKey","activeElement","onPointerDown","onFocus","target","onBlur","window","clearTimeout","setTimeout","onVisibilityChange","visibilityState","addInitialPointerMoveListeners","addEventListener","onInitialPointerMove","removeInitialPointerMoveListeners","removeEventListener"],"sources":["C:/Users/julieta/Documents/GitHub/alvarosiles.com/app/node_modules/react-native-web/dist/exports/StyleSheet/modality.js"],"sourcesContent":["/**\r\n * Adapts focus styles based on the user's active input modality (i.e., how\r\n * they are interacting with the UI right now).\r\n *\r\n * Focus styles are only relevant when using the keyboard to interact with the\r\n * page. If we only show the focus ring when relevant, we can avoid user\r\n * confusion without compromising accessibility.\r\n *\r\n * The script uses two heuristics to determine whether the keyboard is being used:\r\n *\r\n * 1. a keydown event occurred immediately before a focus event;\r\n * 2. a focus event happened on an element which requires keyboard interaction (e.g., a text field);\r\n *\r\n * This software or document includes material copied from or derived from https://github.com/WICG/focus-visible.\r\n * Copyright © 2018 W3C® (MIT, ERCIM, Keio, Beihang).\r\n * W3C Software Notice and License: https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n *\r\n * \r\n */\r\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\r\nvar focusVisibleAttributeName = 'data-focusvisible-polyfill';\r\nvar rule = \":focus:not([\" + focusVisibleAttributeName + \"]){outline: none;}\";\r\n\r\nvar modality = function modality(insertRule) {\r\n  insertRule(rule);\r\n\r\n  if (!canUseDOM) {\r\n    return;\r\n  }\r\n\r\n  var hadKeyboardEvent = true;\r\n  var hadFocusVisibleRecently = false;\r\n  var hadFocusVisibleRecentlyTimeout = null;\r\n  var inputTypesWhitelist = {\r\n    text: true,\r\n    search: true,\r\n    url: true,\r\n    tel: true,\r\n    email: true,\r\n    password: true,\r\n    number: true,\r\n    date: true,\r\n    month: true,\r\n    week: true,\r\n    time: true,\r\n    datetime: true,\r\n    'datetime-local': true\r\n  };\r\n  /**\r\n   * Helper function for legacy browsers and iframes which sometimes focus\r\n   * elements like document, body, and non-interactive SVG.\r\n   */\r\n\r\n  function isValidFocusTarget(el) {\r\n    if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Computes whether the given element should automatically trigger the\r\n   * `focus-visible` attribute being added, i.e. whether it should always match\r\n   * `:focus-visible` when focused.\r\n   */\r\n\r\n\r\n  function focusTriggersKeyboardModality(el) {\r\n    var type = el.type;\r\n    var tagName = el.tagName;\r\n    var isReadOnly = el.readOnly;\r\n\r\n    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !isReadOnly) {\r\n      return true;\r\n    }\r\n\r\n    if (tagName === 'TEXTAREA' && !isReadOnly) {\r\n      return true;\r\n    }\r\n\r\n    if (el.isContentEditable) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Add the `focus-visible` attribute to the given element if it was not added by\r\n   * the author.\r\n   */\r\n\r\n\r\n  function addFocusVisibleAttribute(el) {\r\n    if (el.hasAttribute(focusVisibleAttributeName)) {\r\n      return;\r\n    }\r\n\r\n    el.setAttribute(focusVisibleAttributeName, true);\r\n  }\r\n  /**\r\n   * Remove the `focus-visible` attribute from the given element if it was not\r\n   * originally added by the author.\r\n   */\r\n\r\n\r\n  function removeFocusVisibleAttribute(el) {\r\n    el.removeAttribute(focusVisibleAttributeName);\r\n  }\r\n  /**\r\n   * Remove the `focus-visible` attribute from all elements in the document.\r\n   */\r\n\r\n\r\n  function removeAllFocusVisibleAttributes() {\r\n    var list = document.querySelectorAll(\"[\" + focusVisibleAttributeName + \"]\");\r\n\r\n    for (var i = 0; i < list.length; i += 1) {\r\n      removeFocusVisibleAttribute(list[i]);\r\n    }\r\n  }\r\n  /**\r\n   * Treat `keydown` as a signal that the user is in keyboard modality.\r\n   * Apply `focus-visible` to any current active element and keep track\r\n   * of our keyboard modality state with `hadKeyboardEvent`.\r\n   */\r\n\r\n\r\n  function onKeyDown(e) {\r\n    if (e.key !== 'Tab' && (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)) {\r\n      return;\r\n    }\r\n\r\n    if (isValidFocusTarget(document.activeElement)) {\r\n      addFocusVisibleAttribute(document.activeElement);\r\n    }\r\n\r\n    hadKeyboardEvent = true;\r\n  }\r\n  /**\r\n   * If at any point a user clicks with a pointing device, ensure that we change\r\n   * the modality away from keyboard.\r\n   * This avoids the situation where a user presses a key on an already focused\r\n   * element, and then clicks on a different element, focusing it with a\r\n   * pointing device, while we still think we're in keyboard modality.\r\n   * It also avoids the situation where a user presses on an element within a\r\n   * previously keyboard-focused element (i.e., `e.target` is not the previously\r\n   * focused element, but one of its descendants) and we need to remove the\r\n   * focus ring because a `blur` event doesn't occur.\r\n   */\r\n\r\n\r\n  function onPointerDown(e) {\r\n    if (hadKeyboardEvent === true) {\r\n      removeAllFocusVisibleAttributes();\r\n    }\r\n\r\n    hadKeyboardEvent = false;\r\n  }\r\n  /**\r\n   * On `focus`, add the `focus-visible` attribute to the target if:\r\n   * - the target received focus as a result of keyboard navigation, or\r\n   * - the event target is an element that will likely require interaction\r\n   *   via the keyboard (e.g. a text box)\r\n   */\r\n\r\n\r\n  function onFocus(e) {\r\n    // Prevent IE from focusing the document or HTML element.\r\n    if (!isValidFocusTarget(e.target)) {\r\n      return;\r\n    }\r\n\r\n    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\r\n      addFocusVisibleAttribute(e.target);\r\n    }\r\n  }\r\n  /**\r\n   * On `blur`, remove the `focus-visible` attribute from the target.\r\n   */\r\n\r\n\r\n  function onBlur(e) {\r\n    if (!isValidFocusTarget(e.target)) {\r\n      return;\r\n    }\r\n\r\n    if (e.target.hasAttribute(focusVisibleAttributeName)) {\r\n      // To detect a tab/window switch, we look for a blur event followed\r\n      // rapidly by a visibility change.\r\n      // If we don't see a visibility change within 100ms, it's probably a\r\n      // regular focus change.\r\n      hadFocusVisibleRecently = true;\r\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\r\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\r\n        hadFocusVisibleRecently = false;\r\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\r\n      }, 100);\r\n      removeFocusVisibleAttribute(e.target);\r\n    }\r\n  }\r\n  /**\r\n   * If the user changes tabs, keep track of whether or not the previously\r\n   * focused element had the focus-visible attribute.\r\n   */\r\n\r\n\r\n  function onVisibilityChange(e) {\r\n    if (document.visibilityState === 'hidden') {\r\n      // If the tab becomes active again, the browser will handle calling focus\r\n      // on the element (Safari actually calls it twice).\r\n      // If this tab change caused a blur on an element with focus-visible,\r\n      // re-apply the attribute when the user switches back to the tab.\r\n      if (hadFocusVisibleRecently) {\r\n        hadKeyboardEvent = true;\r\n      }\r\n\r\n      addInitialPointerMoveListeners();\r\n    }\r\n  }\r\n  /**\r\n   * Add a group of listeners to detect usage of any pointing devices.\r\n   * These listeners will be added when the polyfill first loads, and anytime\r\n   * the window is blurred, so that they are active when the window regains\r\n   * focus.\r\n   */\r\n\r\n\r\n  function addInitialPointerMoveListeners() {\r\n    document.addEventListener('mousemove', onInitialPointerMove);\r\n    document.addEventListener('mousedown', onInitialPointerMove);\r\n    document.addEventListener('mouseup', onInitialPointerMove);\r\n    document.addEventListener('pointermove', onInitialPointerMove);\r\n    document.addEventListener('pointerdown', onInitialPointerMove);\r\n    document.addEventListener('pointerup', onInitialPointerMove);\r\n    document.addEventListener('touchmove', onInitialPointerMove);\r\n    document.addEventListener('touchstart', onInitialPointerMove);\r\n    document.addEventListener('touchend', onInitialPointerMove);\r\n  }\r\n\r\n  function removeInitialPointerMoveListeners() {\r\n    document.removeEventListener('mousemove', onInitialPointerMove);\r\n    document.removeEventListener('mousedown', onInitialPointerMove);\r\n    document.removeEventListener('mouseup', onInitialPointerMove);\r\n    document.removeEventListener('pointermove', onInitialPointerMove);\r\n    document.removeEventListener('pointerdown', onInitialPointerMove);\r\n    document.removeEventListener('pointerup', onInitialPointerMove);\r\n    document.removeEventListener('touchmove', onInitialPointerMove);\r\n    document.removeEventListener('touchstart', onInitialPointerMove);\r\n    document.removeEventListener('touchend', onInitialPointerMove);\r\n  }\r\n  /**\r\n   * When the polfyill first loads, assume the user is in keyboard modality.\r\n   * If any event is received from a pointing device (e.g. mouse, pointer,\r\n   * touch), turn off keyboard modality.\r\n   * This accounts for situations where focus enters the page from the URL bar.\r\n   */\r\n\r\n\r\n  function onInitialPointerMove(e) {\r\n    // Work around a Safari quirk that fires a mousemove on <html> whenever the\r\n    // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\r\n    if (e.target.nodeName === 'HTML') {\r\n      return;\r\n    }\r\n\r\n    hadKeyboardEvent = false;\r\n    removeInitialPointerMoveListeners();\r\n  }\r\n\r\n  document.addEventListener('keydown', onKeyDown, true);\r\n  document.addEventListener('mousedown', onPointerDown, true);\r\n  document.addEventListener('pointerdown', onPointerDown, true);\r\n  document.addEventListener('touchstart', onPointerDown, true);\r\n  document.addEventListener('focus', onFocus, true);\r\n  document.addEventListener('blur', onBlur, true);\r\n  document.addEventListener('visibilitychange', onVisibilityChange, true);\r\n  addInitialPointerMoveListeners();\r\n};\r\n\r\nexport default modality;"],"mappings":"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"},"metadata":{},"sourceType":"module"}