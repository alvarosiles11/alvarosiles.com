{"ast":null,"code":"'use strict';\n\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return [decodeURIComponent(components.join(''))];\n  } catch (err) {\n    // Do nothing\n  }\n  if (components.length === 1) {\n    return components;\n  }\n  split = split || 1;\n\n  // Split the array in 2 parts\n  var left = components.slice(0, split);\n  var right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch (err) {\n    var tokens = input.match(singleMatcher) || [];\n    for (var i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher) || [];\n    }\n    return input;\n  }\n}\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  var replaceMap = {\n    '%FE%FF': '\\uFFFD\\uFFFD',\n    '%FF%FE': '\\uFFFD\\uFFFD'\n  };\n  var match = multiMatcher.exec(input);\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch (err) {\n      var result = decode(match[0]);\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n    match = multiMatcher.exec(input);\n  }\n\n  // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n  replaceMap['%C2'] = '\\uFFFD';\n  var entries = Object.keys(replaceMap);\n  for (var i = 0; i < entries.length; i++) {\n    // Replace all decoded components\n    var key = entries[i];\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n  return input;\n}\nmodule.exports = function (encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n  try {\n    encodedURI = encodedURI.replace(/\\+/g, ' ');\n\n    // Try the built in decoder first\n    return decodeURIComponent(encodedURI);\n  } catch (err) {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n};","map":{"version":3,"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","err","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","customDecodeURIComponent","replaceMap","exec","result","entries","Object","keys","key","replace","module","exports","encodedURI","TypeError"],"sources":["C:/Users/julieta/Documents/GitHub/alvarosiles.com/app/node_modules/decode-uri-component/index.js"],"sourcesContent":["'use strict';\r\nvar token = '%[a-f0-9]{2}';\r\nvar singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\r\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\r\n\r\nfunction decodeComponents(components, split) {\r\n\ttry {\r\n\t\t// Try to decode the entire string first\r\n\t\treturn [decodeURIComponent(components.join(''))];\r\n\t} catch (err) {\r\n\t\t// Do nothing\r\n\t}\r\n\r\n\tif (components.length === 1) {\r\n\t\treturn components;\r\n\t}\r\n\r\n\tsplit = split || 1;\r\n\r\n\t// Split the array in 2 parts\r\n\tvar left = components.slice(0, split);\r\n\tvar right = components.slice(split);\r\n\r\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\r\n}\r\n\r\nfunction decode(input) {\r\n\ttry {\r\n\t\treturn decodeURIComponent(input);\r\n\t} catch (err) {\r\n\t\tvar tokens = input.match(singleMatcher) || [];\r\n\r\n\t\tfor (var i = 1; i < tokens.length; i++) {\r\n\t\t\tinput = decodeComponents(tokens, i).join('');\r\n\r\n\t\t\ttokens = input.match(singleMatcher) || [];\r\n\t\t}\r\n\r\n\t\treturn input;\r\n\t}\r\n}\r\n\r\nfunction customDecodeURIComponent(input) {\r\n\t// Keep track of all the replacements and prefill the map with the `BOM`\r\n\tvar replaceMap = {\r\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\r\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\r\n\t};\r\n\r\n\tvar match = multiMatcher.exec(input);\r\n\twhile (match) {\r\n\t\ttry {\r\n\t\t\t// Decode as big chunks as possible\r\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\r\n\t\t} catch (err) {\r\n\t\t\tvar result = decode(match[0]);\r\n\r\n\t\t\tif (result !== match[0]) {\r\n\t\t\t\treplaceMap[match[0]] = result;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmatch = multiMatcher.exec(input);\r\n\t}\r\n\r\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\r\n\treplaceMap['%C2'] = '\\uFFFD';\r\n\r\n\tvar entries = Object.keys(replaceMap);\r\n\r\n\tfor (var i = 0; i < entries.length; i++) {\r\n\t\t// Replace all decoded components\r\n\t\tvar key = entries[i];\r\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\r\n\t}\r\n\r\n\treturn input;\r\n}\r\n\r\nmodule.exports = function (encodedURI) {\r\n\tif (typeof encodedURI !== 'string') {\r\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\r\n\t}\r\n\r\n\ttry {\r\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\r\n\r\n\t\t// Try the built in decoder first\r\n\t\treturn decodeURIComponent(encodedURI);\r\n\t} catch (err) {\r\n\t\t// Fallback to a more advanced decoder\r\n\t\treturn customDecodeURIComponent(encodedURI);\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}